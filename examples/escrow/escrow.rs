use std::time::Duration;
use std::time::Instant;
use std::time::SystemTime;
use lasr::Address;
use lasr::AddressOrNamespace;
use lasr::ArbitraryData;
use lasr::DataValue;
use lasr::Instruction;
use lasr::Metadata;
use lasr::Namespace;
use lasr::PayableContract;
use ethereum_types::U256;
use lasr::ProgramField;
use lasr::ProgramFieldValue;
use lasr::ProgramUpdate;
use lasr::ProgramUpdateField;
use lasr::TokenOrProgramUpdate;
use lasr::TokenUpdate;
use lasr::TransferInstruction;
use lasr::UpdateInstruction;
use serde::Deserialize;
use serde::Serialize;

pub trait Escrow: PayableContract + Serialize + Deserialize<'static> {
    type Conditions: Serialize + Deserialize<'static>;
    /// Takes an address from a depositor, and address to a redeemer,
    /// the deposit token address, the deposit token amount/ID, as well as an 
    /// optional map of conditions which when all are met should equal the 
    /// full deposit amount +/- a fee, anything left over would be auto assumed
    /// to be a fee for the "owner" of this `Escrow` contract.
    ///
    /// Method produces instructions, should produce a minimum of 2 Instructions:
    /// `Transfer`, to tell the protocol to take `deposit` in the `Token` represented 
    /// by `deposit_token_address` from `depositor` account and add it to 
    /// the balance of a `program_address`, i.e. an address generated by the
    /// `generate_program_address` method. 
    ///
    /// Should also generate an `Update` instruction to tell the protocol 
    /// to `Update` the program address account with the Conditions and Maturity
    /// in this scenario, the `Token` `arbitrary_data` field will be used to 
    /// store the conditions and maturity in.
    ///
    /// A third Instruction to `Update` the depositors token arbirary data field 
    /// with a deposit_id which can be a 32 byte array representing a unique id
    /// which can be returned to the depositor so the depositor can inform the redeemer 
    /// of the deposit ID that will need to be used to inform the contract which 
    /// condition is attempting to be met.
    fn deposit(
        depositor: [u8; 20],
        payment_token: [u8; 20], 
        payment_token_amount: U256, 
        redeemer: [u8; 20],
        contracted_item_address: [u8; 20],
        contracted_item: U256,
        // Escrow can also be timed, probably in production would make sense 
        // to have 2 separate methods for timed deposits vs condition based deposits
        // and another for both
        maturity: Option<i64>,
    ) -> Vec<Instruction>; 
    /// Redeemer calls providing the deposit_id, the item_address and the item amount/id 
    /// the protcol `Read`s the program account as a pre-condition (as well as the 
    /// redeemer account to verify the balance/existence of the item). When this 
    /// call is made, the logic implemented here should deserialize the conditions
    /// should check if the condition(s) are met, and will then return 4 `Instruction`s
    /// 1. Transfer the item to the depositor
    /// 2. Transfer the the amount/item for the condition in the deposit_token to the redeemer
    /// from the escrow program account
    /// 3. Update the depositor token to remove the deposit ID 
    /// 4. Update the contract account to "mark" conditions as met, or remove the 
    /// pending escrow altogether so it cannot be triggered again in the future 
    /// to drain the program account from that token
    /// 
    /// An alternative to 4 is that for each escrow a new program account address
    /// can be generated and therefore once the condition(s) are fully met the 
    /// account is zeroed out, or only maintains the fee to the contract owner
    fn redeem(
        escrow_address: [u8; 32],
        deposit_token_address: [u8; 20],
        deposit_id: Option<[u8; 32]>,
        item_address: [u8; 20],
        item: U256
    ) -> Vec<Instruction>;
    /// If the condition is not met in time, the depositor can revoke the escrow
    /// and receive their tokens/item back.
    fn revoke(
        escrow_address: [u8; 32],
        deposit_id: Option<[u8; 32]>,
        depositor_address: [u8; 32], 
        timestamp: Instant, 
        maturity: Duration
    ) -> Vec<Instruction> {
        Vec::new()
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EscrowContract;

impl PayableContract for EscrowContract {
    const NAMESPACE: &'static str = "HelloEscrow"; 
    fn receive_payment(from: lasr::AddressOrNamespace, amount: Option<U256>, token_ids: Vec<U256>) -> Vec<Instruction> {
        vec![
            Instruction::Transfer(
                TransferInstruction::new(
                    Namespace(Self::NAMESPACE.to_string()),
                    from,
                    lasr::AddressOrNamespace::Namespace(
                        Namespace(Self::NAMESPACE.to_string())
                    ),
                    amount,
                    token_ids
            ))
        ]
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct HelloEscrowConditions {
    pub deposit_id: Option<[u8; 32]>,
    pub depositor: [u8; 20],
    pub contracted_item_address: [u8; 20],
    pub contracted_item: U256, 
    pub redeemer: [u8; 20],
    pub payment_token: [u8; 20],
    pub payment_amount: U256,
    pub by: Option<i64> 
}

impl Escrow for EscrowContract {
    type Conditions = HelloEscrowConditions;
    fn deposit(
            depositor: [u8; 20],
            payment_token: [u8; 20], 
            payment_amount: U256, 
            redeemer: [u8; 20],
            contracted_item_address: [u8; 20],
            contracted_item: U256,
            // Escrow can also be timed, probably in production would make sense 
            // to have 2 separate methods for timed deposits vs condition based deposits
            // and another for both
            maturity: Option<i64>,
        ) -> Vec<Instruction> {
        // Create the conditions:
        let conditions = HelloEscrowConditions {
            deposit_id: None,
            depositor,
            contracted_item_address,
            contracted_item,
            redeemer,
            payment_token,
            payment_amount,
            by: maturity
        };

        let serialized_conditions = bincode::serialize(&conditions);
        if let Err(_) = serialized_conditions {
            return vec![]
        }
        let account = AddressOrNamespace::Namespace(Namespace(Self::NAMESPACE.to_string()));
        let program_field = ProgramField::Data;
        let data_value = DataValue::Extend(ArbitraryData::from(serialized_conditions.unwrap_or_default()));
        let program_field_value = ProgramFieldValue::Data(data_value);
        let program_field_updates = ProgramUpdateField::new(program_field, program_field_value);
        let program_update = ProgramUpdate::new(account, vec![program_field_updates]);
        let token_or_program_update = TokenOrProgramUpdate::ProgramUpdate(program_update);

        let update = UpdateInstruction::new(
            vec![token_or_program_update]
        );

        let instruction_1 = Instruction::Update(
            update
        );

        let transfer_instruction = TransferInstruction::new(
            AddressOrNamespace::Address(Address::from(payment_token)),
            AddressOrNamespace::Address(Address::from(depositor)),
            AddressOrNamespace::Namespace(Namespace(Self::NAMESPACE.to_string())),
            Some(payment_amount),
            vec![],
        ); 

        let instruction_2 = Instruction::Transfer(
            transfer_instruction
        ); 

        vec![instruction_1, instruction_2]
    }

    fn redeem(
            escrow_address: [u8; 32],
            deposit_token_address: [u8; 20],
            deposit_id: Option<[u8; 32]>,
            item_address: [u8; 20],
            item: U256
        ) -> Vec<Instruction> {
        todo!()
    }

    fn revoke(
            escrow_address: [u8; 32],
            deposit_id: Option<[u8; 32]>,
            depositor_address: [u8; 32], 
            timestamp: Instant, 
            maturity: Duration
        ) -> Vec<Instruction> {
        todo!()
    }
}

fn main() {
}
